#!/usr/bin/env node
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const semver_1 = __importDefault(require("semver"));
const update_notifier_1 = __importDefault(require("update-notifier"));
const yargs_1 = __importDefault(require("yargs"));
const auth = __importStar(require("./actions/auth"));
const fix_imports_1 = require("./actions/fix-imports");
const info_1 = require("./actions/info");
const init_1 = require("./actions/init");
const localization_strings_1 = require("./actions/localization-strings");
const projectToken = __importStar(require("./actions/project-token"));
const sync_1 = require("./actions/sync");
const upload_bundle_1 = require("./actions/upload-bundle");
const watch_1 = require("./actions/watch");
const config_utils_1 = require("./utils/config-utils");
const error_1 = require("./utils/error");
if (process.env.DEBUG_CHDIR) {
    process.chdir(process.env.DEBUG_CHDIR);
}
// Check once an hour
const pkg = require("../package.json");
const notifier = update_notifier_1.default({ pkg, updateCheckInterval: 1000 * 60 * 60 });
// Workaround for this bug
// https://github.com/yeoman/update-notifier/issues/181
if (!!notifier.update &&
    semver_1.default.gt(notifier.update.latest, notifier.update.current)) {
    notifier.notify();
}
yargs_1.default
    .usage("Usage: $0 <command> [options]")
    .option("auth", {
    describe: "Plasmic auth file to use; by default, uses ~/.plasmic.auth, or the first .plasmic.auth file found in current and parent directories",
})
    .option("config", {
    describe: "Plasmic config file to use; by default, uses the first plasmic.json file found in the current or parent directories",
})
    .option("yes", {
    type: "boolean",
    describe: "Automatic yes to prompts.",
    default: false,
})
    .command("init", "Initializes Plasmic for a project.", (yags) => {
    yags
        .option("enable-skip-auth", {
        describe: "Enable skipping auth, just initialize a plasmic.json",
        type: "boolean",
        default: false,
    })
        .option("host", init_1.getYargsOption("host", "https://studio.plasmic.app"))
        .option("platform", init_1.getYargsOption("platform"))
        .option("code-lang", init_1.getYargsOption("codeLang"))
        .option("code-scheme", init_1.getYargsOption("codeScheme"))
        .option("react-runtime", {
        describe: "React runtime to use; either classic or automatic",
        choices: ["classic", "automatic"],
        default: "classic",
    })
        .option("src-dir", init_1.getYargsOption("srcDir"))
        .option("plasmic-dir", init_1.getYargsOption("plasmicDir"))
        .option("pages-dir", init_1.getYargsOption("pagesDir"))
        .option("style-scheme", init_1.getYargsOption("styleScheme"))
        .option("images-scheme", init_1.getYargsOption("imagesScheme"))
        .option("images-public-dir", init_1.getYargsOption("imagesPublicDir"))
        .option("images-public-url-prefix", init_1.getYargsOption("imagesPublicUrlPrefix"));
}, (argv) => error_1.handleError(init_1.initPlasmic(argv)))
    .command("auth", "Authenticates you to plasmic.", (yags) => {
    yags
        .option("host", {
        describe: "Plasmic host to use",
        type: "string",
        default: "https://studio.plasmic.app",
    })
        .option("check", {
        alias: "c",
        describe: "Just verifies if the current credentials are valid.",
        type: "boolean",
    })
        .option("email", {
        describe: "Print the email of the currently authenticated user and exit.",
        type: "boolean",
    });
}, (argv) => {
    error_1.handleError(auth.auth(argv));
})
    .command("sync", "Syncs designs from Plasmic to local files.", (yags) => configureSyncArgs(yags), (argv) => {
    error_1.handleError(sync_1.sync(argv, {
        source: "cli",
        scheme: "codegen",
        command: "sync",
    }));
})
    .command("watch", "Watches for updates to projects, and syncs them automatically to local files.", (yags) => configureSyncArgs(yags, false), (argv) => {
    error_1.handleError(watch_1.watchProjects(argv, {
        source: "cli",
        scheme: "codegen",
        command: "watch",
    }));
})
    .command("fix-imports", "Fixes import paths after you've moved around Plasmic blackbox files", (yags) => 0, (argv) => error_1.handleError(fix_imports_1.fixImports(argv)))
    .command("info", "Fetches metadata for projects", (yags) => yags.option("projects", {
    alias: "p",
    describe: "ID of plasmic project to check",
    type: "array",
    default: [],
}), (argv) => {
    error_1.handleError(info_1.printProjectInfo(argv));
})
    .command("upload-bundle", false, (yargs) => yargs
    .option("project", {
    alias: "p",
    describe: "ID of Plasmic project to upload the bundle to.",
    type: "string",
})
    .option("bundleName", {
    describe: "Name of the bundle",
    type: "string",
})
    .option("bundleJsFile", {
    describe: "Path of the bundled Javascript file in AMD format",
    type: "string",
})
    .option("cssFiles", {
    describe: "Path of the bundled css files to load",
    type: "array",
    default: [],
})
    .option("metaJsonFile", {
    describe: "Path of the meta data file (in JSON format) describing the component",
    type: "string",
})
    .option("extraPropMetaJsonFile", {
    describe: "Path of the extra meta data file (in JSON format) describing the component's additional controlled properties and initial properties",
    type: "string",
})
    .option("pkgVersion", {
    describe: "version of the package to include in the generated package.json",
    type: "string",
    default: "latest",
})
    .option("genModulePath", {
    describe: "the path of include when generating import statement and generate package.json for. Default to bundleName.",
    type: "string",
})
    .option("themeProviderWrapper", {
    describe: "the wrapper that inject theme to the bundle.",
    type: "string",
})
    .option("themeModuleFile", {
    describe: "the typescript file that contains and exports the implementation of themeProviderWrapper. Used for code generation. It must be specified together with themeProviderWrapper.",
    type: "string",
})
    .option("genCssPaths", {
    describe: "the list of css paths to import in generate code whenever a component in this bundle is used",
    type: "array",
    default: [],
}), (argv) => error_1.handleError(upload_bundle_1.uploadJsBundle(argv)))
    .command("project-token <projectId>", "Get projectApiToken for a given project", (yargs) => yargs
    .positional("projectId", {
    describe: "projectId",
    type: "string",
})
    .option("host", {
    describe: "Plasmic host to use",
    type: "string",
    default: "https://studio.plasmic.app",
}), (argv) => error_1.handleError(projectToken.projectToken(argv)))
    .command("localization-strings", false, (yargs) => yargs
    .option("projects", {
    alias: "p",
    describe: "One or more projects to generate localization strings, separated by comma. Version constraints can be specified using @. Example: projectid, projectid@>=version",
    type: "array",
})
    .option("host", {
    describe: "Plasmic host to use",
    type: "string",
    default: "https://studio.plasmic.app",
})
    .option("format", {
    describe: 'Output format. Either "json", "po" or "lingui"',
    type: "string",
    choices: ["json", "po", "lingui"],
    default: "json",
})
    .option("output", {
    alias: "o",
    describe: "Output file",
    type: "string",
})
    .option("force-overwrite", {
    type: "boolean",
    describe: "Overwrite the output file.",
    default: false,
})
    .option("project-tokens", {
    type: "array",
    default: [],
    describe: "(Optional) List of project API tokens to be used for auth, in the format PROJECT_ID:PROJECT_API_TOKEN (the pairs should be separated by comma)",
}), (argv) => error_1.handleError(localization_strings_1.localizationStrings(argv)))
    .demandCommand()
    .strict()
    .help("h")
    .alias("h", "help").argv;
function configureSyncArgs(yags, includeQuietOption = true) {
    let args = yags
        .option("projects", {
        alias: "p",
        describe: "One or more projects to sync, separated by comma. Version constraints can be specified using @. Example: projectid, projectid@>=version",
        type: "array",
        default: [],
    })
        .option("force", {
        type: "boolean",
        describe: "Force sync to bypass specified version ranges.",
        default: false,
    })
        .option("loader-config", {
        type: "string",
        describe: "Path to loader config file, and causes CLI to run in PlasmicLoader mode.",
        hidden: true,
        default: config_utils_1.LOADER_CONFIG_FILE_NAME,
    })
        .option("non-recursive", {
        type: "boolean",
        describe: "Do not recursively sync dependencies, only sync the specified projects",
        default: false,
    })
        .option("force-overwrite", {
        type: "boolean",
        describe: "Overwrite the skeleton file with newly generated version. Useful when switching between codegen schemes.",
        default: false,
    })
        .option("append-jsx-on-missing-base", {
        type: "boolean",
        describe: "When the base metadata is missing to perform the three-way merge for direct edit component, append the jsx of the new version so that user can perform manual merge.",
        default: false,
    })
        .option("new-component-scheme", {
        type: "string",
        choices: ["blackbox", "direct"],
        describe: "Sync the new components using this code scheme rather than the default code scheme.",
    })
        .option("ignore-post-sync", {
        type: "boolean",
        describe: "Ignore post-sync commands in plasmic.json",
        default: false,
    })
        .option("metadata", {
        type: "string",
        describe: "Pass metadata through to the server. Use querystring format (e.g. command=sync&source=cli&cli_version=1.0.0",
        default: "source=cli",
        hidden: true,
    })
        .option("all-files", {
        type: "boolean",
        describe: "Sync all files, including those that haven't changed since last sync",
        default: "",
    });
    if (includeQuietOption) {
        args = args.option("quiet", {
            type: "boolean",
            describe: "Do not inform each asset to be synced",
            default: false,
        });
    }
    return args;
}
