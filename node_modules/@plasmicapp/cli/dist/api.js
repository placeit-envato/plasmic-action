"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlasmicApi = exports.AppServerError = void 0;
const code_merger_1 = require("@plasmicapp/code-merger");
const axios_1 = __importDefault(require("axios"));
const socket_io_client_1 = __importDefault(require("socket.io-client"));
const config_utils_1 = require("./utils/config-utils");
const error_1 = require("./utils/error");
class AppServerError extends Error {
    constructor(message) {
        super(message);
    }
}
exports.AppServerError = AppServerError;
class PlasmicApi {
    constructor(auth) {
        this.auth = auth;
    }
    genStyleConfig(styleOpts) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.post(`${this.codegenHost}/api/v1/code/style-config`, styleOpts);
            return result.data;
        });
    }
    /**
     * Sync resolution - Given a fuzzy idea of what the user wants,
     * (i.e. a versionRange and component names),
     * ask the server for the exact references for a later call to `projectComponents`
     * - For components specified in the parameters - the server will return the latest version that satisfies the versionRange
     * - Any conflicting versions will be returned in `conflicts`, and should cause the client's sync to abort
     * @param projects
     * @param recursive
     */
    resolveSync(projects, recursive) {
        return __awaiter(this, void 0, void 0, function* () {
            const resp = yield this.post(`${this.codegenHost}/api/v1/code/resolve-sync`, {
                projects,
                recursive,
            });
            const versionResolution = resp.data;
            return Object.assign({}, versionResolution);
        });
    }
    getCurrentUser() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield axios_1.default.get(`${this.studioHost}/api/v1/auth/self`, {
                headers: this.makeHeaders(),
            });
        });
    }
    requiredPackages() {
        return __awaiter(this, void 0, void 0, function* () {
            const resp = yield this.post(`${this.codegenHost}/api/v1/code/required-packages`);
            return Object.assign({}, resp.data);
        });
    }
    latestCodegenVersion() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.codegenVersion) {
                const resp = yield this.post(`${this.codegenHost}/api/v1/code/latest-codegen-version`);
                this.codegenVersion = resp.data;
            }
            return this.codegenVersion;
        });
    }
    /**
     * Code-gen endpoint.
     * This will fetch components at an exact specified version.
     * If you don't know what version should be used, call `resolveSync` first.
     * @param projectId
     * @param cliVersion
     * @param reactWebVersion
     * @param newCompScheme
     * @param existingCompScheme
     * @param componentIdOrNames
     * @param version
     */
    projectComponents(projectId, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.post(`${this.codegenHost}/api/v1/projects/${projectId}/code/components`, Object.assign({}, opts));
            return result.data;
        });
    }
    projectMeta(projectId) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.post(`${this.codegenHost}/api/v1/projects/${projectId}/code/meta`);
            return result.data;
        });
    }
    genLocalizationStrings(projects, format, projectIdsAndTokens) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.get(`${this.codegenHost}/api/v1/localization/gen-texts?format=${format}&preview=true&${projects
                .map((p) => `projectId=${p}`)
                .join("&")}`, undefined, {
                "x-plasmic-api-project-tokens": projectIdsAndTokens
                    .map(({ projectId, projectApiToken }) => `${projectId}:${projectApiToken}`)
                    .join(","),
            });
            return result.data;
        });
    }
    uploadBundle(projectId, bundleName, bundleJs, css, metaJson, genModulePath, genCssPaths, pkgVersion, extraPropMetaJson, themeProviderWrapper, themeModule) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.post(`${this.codegenHost}/api/v1/projects/${projectId}/jsbundle/upload`, {
                projectId,
                bundleName,
                bundleJs,
                css,
                metaJson,
                genModulePath,
                genCssPaths,
                pkgVersion,
                extraPropMetaJson,
                themeProviderWrapper,
                themeModule,
            });
            return result.data;
        });
    }
    projectStyleTokens(projectId, versionRange) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.post(`${this.codegenHost}/api/v1/projects/${projectId}/code/tokens`, { versionRange });
            return result.data;
        });
    }
    projectIcons(projectId, versionRange, iconIds) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.post(`${this.codegenHost}/api/v1/projects/${projectId}/code/icons`, { versionRange, iconIds });
            return result.data;
        });
    }
    projectSyncMetadata(projectId, revision, rethrowAppError) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.post(`${this.codegenHost}/api/v1/projects/${projectId}/code/project-sync-metadata`, { revision }, rethrowAppError);
            return code_merger_1.ProjectSyncMetadataModel.fromJson(result.data);
        });
    }
    connectSocket() {
        const socket = socket_io_client_1.default.connect(this.studioHost, {
            path: `/api/v1/socket`,
            transportOptions: {
                polling: {
                    extraHeaders: this.makeHeaders(),
                },
            },
        });
        return socket;
    }
    // If rethrowAppError is true, we will throw an exception with the error
    // message
    post(url, data, rethrowAppError) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield axios_1.default.post(url, Object.assign({ projectIdsAndTokens: this.projectIdsAndTokens }, data), {
                    headers: this.makeHeaders(),
                });
            }
            catch (e) {
                const error = e;
                const errorMsg = this.makeErrorMessage(error);
                if (rethrowAppError) {
                    throw new AppServerError(errorMsg);
                }
                if (!errorMsg) {
                    throw e;
                }
                throw new error_1.HandledError(errorMsg);
            }
        });
    }
    get(url, rethrowAppError, extraHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield axios_1.default.get(url, {
                    headers: Object.assign(Object.assign({}, this.makeHeaders()), (extraHeaders !== null && extraHeaders !== void 0 ? extraHeaders : {})),
                });
            }
            catch (e) {
                const error = e;
                const errorMsg = this.makeErrorMessage(error);
                if (rethrowAppError) {
                    throw new AppServerError(errorMsg);
                }
                if (!errorMsg) {
                    throw e;
                }
                throw new error_1.HandledError(errorMsg);
            }
        });
    }
    makeErrorMessage(error) {
        var _a, _b;
        const response = error.response;
        if (!response) {
            return undefined;
        }
        if (response.status === 403) {
            return `Incorrect Plasmic credentials; please check your .plasmic.auth file or your project API tokens.`;
        }
        if ((_b = (_a = response.data) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.message) {
            return response.data.error.message;
        }
        else if (response.data) {
            return `Error: request failed with status code ${response.status}. The response is
  ${response.data}`;
        }
        else {
            return undefined;
        }
    }
    makeHeaders() {
        const headers = {
            "x-plasmic-api-user": this.auth.user,
            "x-plasmic-api-token": this.auth.token,
        };
        if (this.auth.basicAuthUser && this.auth.basicAuthPassword) {
            const authString = Buffer.from(`${this.auth.basicAuthUser}:${this.auth.basicAuthPassword}`).toString("base64");
            headers["Authorization"] = `Basic ${authString}`;
        }
        return headers;
    }
    attachProjectIdsAndTokens(idsAndTokens) {
        this.projectIdsAndTokens = idsAndTokens;
    }
    get studioHost() {
        return this.auth.host;
    }
    get codegenHost() {
        if (!this.auth.host || this.auth.host === config_utils_1.DEFAULT_HOST) {
            return "https://codegen.plasmic.app";
        }
        else {
            return this.auth.host;
        }
    }
}
exports.PlasmicApi = PlasmicApi;
