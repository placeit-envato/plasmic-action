"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.sync = void 0;
const chalk_1 = __importDefault(require("chalk"));
const child_process_1 = require("child_process");
const lodash_1 = __importDefault(require("lodash"));
const upath_1 = __importDefault(require("upath"));
const deps_1 = require("../deps");
const checksum_1 = require("../utils/checksum");
const code_utils_1 = require("../utils/code-utils");
const config_utils_1 = require("../utils/config-utils");
const error_1 = require("../utils/error");
const file_utils_1 = require("../utils/file-utils");
const get_context_1 = require("../utils/get-context");
const help_1 = require("../utils/help");
const lang_utils_1 = require("../utils/lang-utils");
const npm_utils_1 = require("../utils/npm-utils");
const resolve_utils_1 = require("../utils/resolve-utils");
const semver = __importStar(require("../utils/semver"));
const user_utils_1 = require("../utils/user-utils");
const sync_components_1 = require("./sync-components");
const sync_global_contexts_1 = require("./sync-global-contexts");
const sync_global_variants_1 = require("./sync-global-variants");
const sync_icons_1 = require("./sync-icons");
const sync_images_1 = require("./sync-images");
const sync_styles_1 = require("./sync-styles");
function ensureRequiredPackages(context, baseDir, yes) {
    return __awaiter(this, void 0, void 0, function* () {
        const requireds = yield context.api.requiredPackages();
        const confirmInstall = (pkg, requiredVersion, opts) => __awaiter(this, void 0, void 0, function* () {
            let success = false;
            const command = npm_utils_1.installCommand(pkg, baseDir, opts);
            const upgrade = yield user_utils_1.confirmWithUser(`A more recent version of ${pkg} >=${requiredVersion} is required. Would you like to upgrade via "${command}"?`, yes);
            if (upgrade) {
                success = npm_utils_1.installUpgrade(pkg, baseDir, opts);
            }
            else {
                success = false;
            }
            if (!success) {
                throw new error_1.HandledError(`Upgrading ${pkg} is required to continue.`);
            }
        });
        const cliVersion = npm_utils_1.getCliVersion();
        if (!cliVersion || semver.gt(requireds["@plasmicapp/cli"], cliVersion)) {
            const isGlobal = npm_utils_1.isCliGloballyInstalled(context.rootDir);
            yield confirmInstall("@plasmicapp/cli", requireds["@plasmicapp/cli"], {
                global: isGlobal,
                dev: true,
            });
            deps_1.logger.info(chalk_1.default.bold("@plasmicapp/cli has been upgraded; please try again!"));
            // Exit so the user can run again with the new cli
            throw new error_1.HandledError();
        }
        const reactWebVersion = npm_utils_1.findInstalledVersion(context, baseDir, "@plasmicapp/react-web");
        if (!reactWebVersion ||
            semver.gt(requireds["@plasmicapp/react-web"], reactWebVersion)) {
            yield confirmInstall("@plasmicapp/react-web", requireds["@plasmicapp/react-web"], { global: false, dev: false });
        }
        const hostVersion = npm_utils_1.findInstalledVersion(context, baseDir, "@plasmicapp/host");
        if (!hostVersion || semver.gt(requireds["@plasmicapp/host"], hostVersion)) {
            yield confirmInstall("@plasmicapp/host", requireds["@plasmicapp/host"], {
                global: false,
                dev: false,
            });
        }
        if (context.config.code.reactRuntime === "automatic") {
            // Using automatic runtime requires installing the @plasmicapp/react-web-runtime package
            const runtimeVersion = npm_utils_1.findInstalledVersion(context, baseDir, "@plasmicapp/react-web-runtime");
            if (!runtimeVersion ||
                semver.gt(requireds["@plasmicapp/react-web-runtime"], runtimeVersion)) {
                yield confirmInstall("@plasmicapp/react-web-runtime", requireds["@plasmicapp/react-web-runtime"], { global: false, dev: false });
            }
        }
    });
}
function getLoaderConfigPath(opts) {
    return opts.loaderConfig || config_utils_1.LOADER_CONFIG_FILE_NAME;
}
function maybeReadLoaderConfig(opts) {
    const path = getLoaderConfigPath(opts);
    if (!file_utils_1.existsBuffered(path)) {
        return {};
    }
    return JSON.parse(file_utils_1.readFileText(path));
}
function writeLoaderConfig(opts, config) {
    const loaderConfigPath = getLoaderConfigPath(opts);
    file_utils_1.writeFileText(loaderConfigPath, code_utils_1.formatAsLocal(JSON.stringify(config), loaderConfigPath, opts.baseDir));
}
/**
 * Sync will always try to sync down a set of components that are version-consistent among specified projects.
 * (we only allow 1 version per projectId).
 * NOTE: the repo/plasmic.json might include projects with conflicting versions in its dependency tree.
 * We leave it to the user to sync all projects if they want us to catch/prevent this.
 * @param opts
 */
function sync(opts, metadataDefaults) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        // Initially allow for a missing auth. Only require an auth once we need to fetch new or updated API tokens for any
        // projects.
        if (!opts.baseDir)
            opts.baseDir = process.cwd();
        const baseDir = opts.baseDir;
        let context = yield get_context_1.getContext(opts, { enableSkipAuth: true });
        const isFirstRun = context.config.projects.length === 0;
        if (!opts.skipUpgradeCheck) {
            yield ensureRequiredPackages(context, opts.baseDir, opts.yes);
        }
        fixFileExtension(context);
        file_utils_1.assertAllPathsInRootDir(context);
        const loaderConfig = process.env.PLASMIC_LOADER
            ? maybeReadLoaderConfig(opts)
            : {};
        const projectIdToToken = new Map([...context.config.projects, ...((_a = loaderConfig === null || loaderConfig === void 0 ? void 0 : loaderConfig.projects) !== null && _a !== void 0 ? _a : [])]
            .filter((p) => p.projectApiToken)
            .map((p) => lang_utils_1.tuple(p.projectId, p.projectApiToken)));
        // Resolve what will be synced
        const projectConfigMap = lodash_1.default.keyBy(context.config.projects, (p) => p.projectId);
        const projectWithVersion = opts.projects.map((p) => {
            var _a;
            const [projectIdToken, versionRange] = p.split("@");
            const [projectId, projectApiToken] = projectIdToken.split(":");
            return {
                projectId,
                versionRange: versionRange || ((_a = projectConfigMap[projectId]) === null || _a === void 0 ? void 0 : _a.version) || "latest",
                componentIdOrNames: undefined,
                projectApiToken: projectApiToken || projectIdToToken.get(projectId),
                indirect: false,
            };
        });
        const projectSyncParams = projectWithVersion.length
            ? projectWithVersion
            : context.config.projects.map((p) => ({
                projectId: p.projectId,
                versionRange: p.version,
                componentIdOrNames: undefined,
                projectApiToken: p.projectApiToken,
                indirect: !!p.indirect,
            }));
        // Short-circuit if nothing to sync
        if (projectSyncParams.length === 0) {
            throw new error_1.HandledError("Don't know which projects to sync. Please specify via --projects");
        }
        // If there are any missing projectApiTokens, reload the context, this time requiring auth, so that we can fetch the
        // projectApiTokens from the server (as a user that has permission to do so).
        if (projectSyncParams.some((p) => !p.projectApiToken)) {
            try {
                context = yield get_context_1.getContext(opts);
            }
            catch (e) {
                if (e.message.includes("Unable to authenticate Plasmic")) {
                    const configFileName = process.env.PLASMIC_LOADER
                        ? config_utils_1.LOADER_CONFIG_FILE_NAME
                        : config_utils_1.CONFIG_FILE_NAME;
                    throw new error_1.HandledError(`Unable to authenticate Plasmic. Please run 'plasmic auth' or check the projectApiTokens in your ${configFileName}, and try again.`);
                }
            }
        }
        // Pass just the root IDs and tokens that we do have for the resolve call. (In reality it doesn't need any of this
        // because it only consults the projectApiToken within projectSyncParams; we could just attach [].)
        context.api.attachProjectIdsAndTokens(projectSyncParams.flatMap((p) => p.projectApiToken
            ? [{ projectId: p.projectId, projectApiToken: p.projectApiToken }]
            : []));
        const versionResolution = yield context.api.resolveSync(projectSyncParams, true // we always want to get dependency data
        );
        // Make sure the resolution is compatible with plasmic.json and plasmic.lock
        const projectsToSync = yield resolve_utils_1.checkVersionResolution(versionResolution, context, opts);
        if (projectsToSync.length <= 0) {
            deps_1.logger.info("Your projects are up-to-date with respect to your specified version ranges. Nothing to sync.");
            return;
        }
        const summary = new Map();
        const pendingMerge = new Array();
        // The resolveSync call returns the project API tokens for all relevant projects (sources and dependencies).
        // resolveSync is what does this because it's what is computing all concrete versions to sync, and the dependency
        // graph can change with any version. Subsequent API calls require the exact API tokens, not to redo this work on each
        // call. Only resolveSync accepts just the API tokens for the root projects.
        //
        // We shouldn't simply use projectsToSync, because this list excludes up-to-date projects, but syncing a dependent
        // project still requires tokens to the dependencies.
        const projectIdsAndTokens = [
            ...versionResolution.projects,
            ...versionResolution.dependencies,
        ].map((p) => lodash_1.default.pick(p, "projectId", "projectApiToken"));
        context.api.attachProjectIdsAndTokens(projectIdsAndTokens);
        const externalNpmPackages = new Set();
        const externalCssImports = new Set();
        // Perform the actual sync
        yield file_utils_1.withBufferedFs(() => __awaiter(this, void 0, void 0, function* () {
            var _b;
            // Sync in sequence (no parallelism)
            // going in reverse to get leaves of the dependency tree first
            for (const projectMeta of projectsToSync) {
                yield syncProject(context, opts, projectIdsAndTokens, projectMeta.projectId, projectMeta.componentIds, projectMeta.version, projectMeta.dependencies, summary, pendingMerge, projectMeta.indirect, externalNpmPackages, externalCssImports, metadataDefaults);
            }
            // Materialize scheme into each component config.
            context.config.projects.forEach((p) => p.components.forEach((c) => {
                if (c.type === "managed" && !c.scheme) {
                    c.scheme = context.config.code.scheme;
                }
            }));
            yield syncStyleConfig(context, yield context.api.genStyleConfig(context.config.style));
            // Update project version and indirect status if specified and
            // successfully synced.
            if (projectWithVersion.length) {
                const versionMap = {};
                projectWithVersion.forEach((p) => (versionMap[p.projectId] = p.versionRange));
                const indirectMap = {};
                projectsToSync.forEach((p) => (indirectMap[p.projectId] = p.indirect));
                context.config.projects.forEach((p) => {
                    p.version = versionMap[p.projectId] || p.version;
                    // Only update `indirect` if it is set in current config.
                    if (p.projectId in indirectMap && p.indirect) {
                        p.indirect = indirectMap[p.projectId];
                    }
                });
            }
            // Fix imports
            const fixImportContext = code_utils_1.mkFixImportContext(context.config);
            for (const m of pendingMerge) {
                const resolvedEditedFile = code_utils_1.replaceImports(context, m.editedSkeletonFile, m.skeletonModulePath, fixImportContext, true, baseDir);
                const resolvedNewFile = code_utils_1.replaceImports(context, m.newSkeletonFile, m.skeletonModulePath, fixImportContext, true, baseDir);
                yield m.merge(resolvedNewFile, resolvedEditedFile);
            }
            // Now we know config.components are all correct, so we can go ahead and fix up all the import statements
            yield code_utils_1.fixAllImportStatements(context, opts.baseDir, summary);
            if (process.env.PLASMIC_LOADER) {
                const rootProjectIds = new Set(projectSyncParams.map((p) => p.projectId));
                const freshIdsAndTokens = projectIdsAndTokens
                    .filter((p) => rootProjectIds.has(p.projectId))
                    .map((p) => lodash_1.default.pick(p, "projectId", "projectApiToken"));
                const config = Object.assign(Object.assign({}, loaderConfig), { projects: lodash_1.default.sortBy(lodash_1.default.uniqBy([...freshIdsAndTokens, ...((_b = loaderConfig === null || loaderConfig === void 0 ? void 0 : loaderConfig.projects) !== null && _b !== void 0 ? _b : [])], (p) => p.projectId), (p) => p.projectId) });
                writeLoaderConfig(opts, config);
            }
            const codegenVersion = yield context.api.latestCodegenVersion();
            context.lock.projects.forEach((p) => {
                if (projectsToSync.some((syncedProject) => syncedProject.projectId === p.projectId)) {
                    p.codegenVersion = codegenVersion;
                }
            });
            // Write the new ComponentConfigs to disk
            yield config_utils_1.updateConfig(context, context.config, baseDir);
        }));
        yield checkExternalPkgs(context, baseDir, opts, Array.from(externalNpmPackages.keys()));
        if (!opts.quiet && externalCssImports.size > 0) {
            deps_1.logger.info(chalk_1.default.cyanBright.bold(`IMPORTANT: This project uses external packages and styles. Make sure to import the following global CSS: ` +
                Array.from(externalCssImports.keys())
                    .map((stmt) => `"${stmt}"`)
                    .join(", ")));
        }
        // Post-sync commands
        if (!opts.ignorePostSync) {
            for (const cmd of context.config.postSyncCommands || []) {
                child_process_1.spawnSync(cmd, { shell: true, stdio: "inherit" });
            }
        }
        if (isFirstRun) {
            if (!process.env.QUIET) {
                help_1.printFirstSyncInfo(context);
            }
        }
    });
}
exports.sync = sync;
function checkExternalPkgs(context, baseDir, opts, pkgs) {
    return __awaiter(this, void 0, void 0, function* () {
        const missingPkgs = pkgs.filter((pkg) => {
            const installedPkg = npm_utils_1.findInstalledVersion(context, baseDir, pkg);
            return !installedPkg;
        });
        if (missingPkgs.length > 0) {
            const upgrade = yield user_utils_1.confirmWithUser(`The following packages aren't installed but are required by some projects, would you like to install them? ${missingPkgs.join(", ")}`, opts.yes);
            if (upgrade) {
                npm_utils_1.installUpgrade(missingPkgs.join(" "), baseDir);
            }
        }
    });
}
function maybeRenamePathExt(context, path, ext, opts) {
    if (!path) {
        return path;
    }
    const correctPath = `${file_utils_1.stripExtension(path, true)}${ext}`;
    if (path !== correctPath) {
        try {
            file_utils_1.renameFile(context, path, correctPath);
        }
        catch (e) {
            if (!(opts === null || opts === void 0 ? void 0 : opts.continueOnFailure)) {
                throw e;
            }
            else {
                deps_1.logger.warn(e);
            }
        }
    }
    return correctPath;
}
function fixFileExtension(context) {
    const cssExt = context.config.style.scheme === "css-modules" ? ".module.css" : ".css";
    context.config.style.defaultStyleCssFilePath = maybeRenamePathExt(context, context.config.style.defaultStyleCssFilePath, cssExt, { continueOnFailure: true });
    context.config.projects.forEach((project) => {
        project.cssFilePath = maybeRenamePathExt(context, project.cssFilePath, cssExt, { continueOnFailure: true });
        project.components.forEach((component) => {
            component.cssFilePath = maybeRenamePathExt(context, component.cssFilePath, cssExt, { continueOnFailure: true });
        });
    });
}
function syncProject(context, opts, projectIdsAndTokens, projectId, componentIds, projectVersion, dependencies, summary, pendingMerge, indirect, externalNpmPackages, externalCssImports, metadataDefaults) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const newComponentScheme = opts.newComponentScheme || context.config.code.scheme;
        const existingProject = context.config.projects.find((p) => p.projectId === projectId);
        const existingCompScheme = ((existingProject === null || existingProject === void 0 ? void 0 : existingProject.components) || []).map((c) => [c.id, c.scheme]);
        const projectApiToken = lang_utils_1.ensure((_a = projectIdsAndTokens.find((p) => p.projectId === projectId)) === null || _a === void 0 ? void 0 : _a.projectApiToken, `Could not find the API token for project ${projectId} in list: ${JSON.stringify(projectIdsAndTokens)}`);
        const existingChecksums = checksum_1.getChecksums(context, opts, projectId, componentIds);
        // Server-side code-gen
        const projectBundle = yield context.api.projectComponents(projectId, {
            platform: context.config.platform,
            newCompScheme: newComponentScheme,
            existingCompScheme,
            componentIdOrNames: componentIds,
            version: projectVersion,
            imageOpts: context.config.images,
            stylesOpts: context.config.style,
            checksums: existingChecksums,
            codeOpts: context.config.code,
            metadata: get_context_1.generateMetadata(Object.assign(Object.assign({}, metadataDefaults), { platform: context.config.platform }), opts.metadata),
            indirect,
            wrapPagesWithGlobalContexts: context.config.wrapPagesWithGlobalContexts,
        });
        // Convert from TSX => JSX
        if (context.config.code.lang === "js") {
            projectBundle.components.forEach((c) => {
                [c.renderModuleFileName, c.renderModule] = code_utils_1.maybeConvertTsxToJsx(c.renderModuleFileName, c.renderModule, opts.baseDir);
                [c.skeletonModuleFileName, c.skeletonModule] = code_utils_1.maybeConvertTsxToJsx(c.skeletonModuleFileName, c.skeletonModule, opts.baseDir);
            });
            projectBundle.iconAssets.forEach((icon) => {
                [icon.fileName, icon.module] = code_utils_1.maybeConvertTsxToJsx(icon.fileName, icon.module, opts.baseDir);
            });
            projectBundle.globalVariants.forEach((gv) => {
                [gv.contextFileName, gv.contextModule] = code_utils_1.maybeConvertTsxToJsx(gv.contextFileName, gv.contextModule, opts.baseDir);
            });
            (projectBundle.projectConfig.jsBundleThemes || []).forEach((theme) => {
                [theme.themeFileName, theme.themeModule] = code_utils_1.maybeConvertTsxToJsx(theme.themeFileName, theme.themeModule, opts.baseDir);
            });
        }
        yield sync_global_variants_1.syncGlobalVariants(context, projectBundle.projectConfig, projectBundle.globalVariants, projectBundle.checksums, opts.baseDir);
        yield syncProjectConfig(context, projectBundle.projectConfig, projectApiToken, projectVersion, dependencies, projectBundle.components, opts.forceOverwrite, !!opts.appendJsxOnMissingBase, summary, pendingMerge, projectBundle.checksums, opts.baseDir, indirect);
        syncCodeComponentsMeta(context, projectId, projectBundle.codeComponentMetas);
        yield sync_styles_1.upsertStyleTokens(context, projectBundle.usedTokens, projectBundle.projectConfig.projectId);
        yield sync_icons_1.syncProjectIconAssets(context, projectId, projectVersion, projectBundle.iconAssets, projectBundle.checksums, opts.baseDir);
        yield sync_images_1.syncProjectImageAssets(context, projectId, projectVersion, projectBundle.imageAssets, projectBundle.checksums);
        (projectBundle.usedNpmPackages || []).forEach((pkg) => externalNpmPackages.add(pkg));
        (projectBundle.externalCssImports || []).forEach((css) => externalCssImports.add(css));
    });
}
function syncStyleConfig(context, response) {
    return __awaiter(this, void 0, void 0, function* () {
        const expectedPath = context.config.style.defaultStyleCssFilePath ||
            upath_1.default.join(context.config.defaultPlasmicDir, response.defaultStyleCssFileName);
        context.config.style.defaultStyleCssFilePath = expectedPath;
        yield file_utils_1.writeFileContent(context, expectedPath, response.defaultStyleCssRules, {
            force: true,
        });
    });
}
function syncProjectConfig(context, projectBundle, projectApiToken, version, dependencies, componentBundles, forceOverwrite, appendJsxOnMissingBase, summary, pendingMerge, checksums, baseDir, indirect) {
    return __awaiter(this, void 0, void 0, function* () {
        const defaultCssFilePath = file_utils_1.defaultResourcePath(context, projectBundle.projectName, projectBundle.cssFileName);
        const isNew = !context.config.projects.find((p) => p.projectId === projectBundle.projectId);
        const projectConfig = config_utils_1.getOrAddProjectConfig(context, projectBundle.projectId, config_utils_1.createProjectConfig({
            projectId: projectBundle.projectId,
            projectApiToken,
            projectName: projectBundle.projectName,
            version,
            cssFilePath: defaultCssFilePath,
            indirect,
        }));
        // Update missing/outdated props
        projectConfig.projectName = projectBundle.projectName;
        if (!projectConfig.cssFilePath) {
            projectConfig.cssFilePath = defaultCssFilePath;
        }
        // plasmic.lock
        const projectLock = config_utils_1.getOrAddProjectLock(context, projectConfig.projectId);
        projectLock.version = version;
        projectLock.dependencies = dependencies;
        projectLock.lang = context.config.code.lang;
        if (projectBundle.cssRules) {
            const formattedCssRules = code_utils_1.formatAsLocal(projectBundle.cssRules, projectConfig.cssFilePath, baseDir);
            // Write out project css
            yield file_utils_1.writeFileContent(context, projectConfig.cssFilePath, formattedCssRules, {
                force: !isNew,
            });
        }
        projectLock.fileLocks = projectLock.fileLocks.filter((fileLock) => fileLock.type !== "projectCss");
        projectLock.fileLocks.push({
            assetId: projectConfig.projectId,
            type: "projectCss",
            checksum: checksums.projectCssChecksum,
        });
        /*
        for (const theme of projectBundle.jsBundleThemes) {
          if (!projectConfig.jsBundleThemes) {
            projectConfig.jsBundleThemes = [];
          }
          let themeConfig = projectConfig.jsBundleThemes.find(
            (c) => c.bundleName === theme.bundleName
          );
          if (!themeConfig) {
            const themeFilePath = defaultResourcePath(
              context,
              projectConfig,
              theme.themeFileName
            );
            themeConfig = { themeFilePath, bundleName: theme.bundleName };
            projectConfig.jsBundleThemes.push(themeConfig);
          }
          const formatted = formatAsLocal(
            theme.themeModule,
            themeConfig.themeFilePath
          );
          await writeFileContent(context, themeConfig.themeFilePath, formatted, {
            force: true,
          });
        }
        */
        if (projectConfig.jsBundleThemes &&
            projectConfig.jsBundleThemes.length === 0) {
            delete projectConfig.jsBundleThemes;
        }
        yield sync_global_contexts_1.syncGlobalContexts(context, projectBundle, projectConfig, projectLock, checksums, baseDir);
        // Write out components
        yield sync_components_1.syncProjectComponents(context, projectConfig, version, componentBundles, forceOverwrite, appendJsxOnMissingBase, summary, pendingMerge, projectLock, checksums, baseDir);
    });
}
function syncCodeComponentsMeta(context, projectId, codeComponentBundles) {
    const projectConfig = config_utils_1.getOrAddProjectConfig(context, projectId);
    projectConfig.codeComponents = codeComponentBundles.map((meta) => ({
        id: meta.id,
        name: meta.name,
        componentImportPath: meta.importPath,
    }));
}
